# 第 9 章 客户端检测

浏览器提供商虽然在实现公共接口方面投入了很多精力，但结果仍然是每一种浏览器都有各自的长处，也都有各自的缺点。即使是那些跨平台的浏览器，虽然从技术上看版本相同，也照样存在不一致性问题。

面对普遍存在的不一致性问题，开发人员要么采取迁就各方的“最小公分母”策略，要么（也是更常见的）就得利用各种**客户端检测**方法，来突破或者规避种种局限性。

检测 Web 客户端的手段很多，而且各有利弊。但最重要的还是要知道，不到万不得已，就不要使用客户端检测。只要能找到更通用的方法，就应该优先采用更通用的方法。一言以蔽之，先设计最通用的方案，然后再使用特定于浏览器的技术增强该方案。



## 9.0 预览

客户端检测是JavaScript开发中最具争议的一个话题。由于浏览器间存在差别，通常需要根据不同浏览器的能力分别编写不同的代码。有不少客户端检测方法，但下列时最经常使用的。

* 能力检测：在编写代码之前先检测特定浏览器的能力；
* 怪癖检测：怪癖实际上是浏览器实现中存在的bug。怪癖检测通常涉及到运行一小段代码，然后确定浏览器是否存在某个怪癖；
* 用户代理检测：通过检测用户代理字符串来识别浏览器。

再决定使用哪种客户端检测方法时，一般应优先考虑使用能力检测。怪癖检测是确定应该如何处理代码的第二选择。而用户代理检测则是客户端检测的最后一种方案，因为这种方法对用户代理字符串具有很强的依赖性。



## 9.1 能力检测

最常用也最为人们广泛接受的客户端检测形式是**能力检测**（又称**特性检测**）。能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力。

采用这种方式不必顾及特定的浏览器如何如何，只要确定浏览器支持特定的能力，就可以给出解决方案。能力检测的基本模式如下：

```javascript
if (object.propertyInQuestion){
    //使用 object.propertyInQuestion
}
```

举例来说，IE5.0 之前的版本不支持 document.getElementById() 这个 DOM 方法。尽管可以使用非标准的 document.all 属性实现相同的目的，但 IE 的早期版本中确实不存在 document.getElementById() 。于是，也就有了类似下面的能力检测代码：

```javascript
function getElement(id){
    if (document.getElementById){
        return document.getElementById(id);
    } else if (document.all){
        return document.all[id];
      } else {
        throw new Error("No way to retrieve element!");
    }
}
```

要理解能力检测，首先必须理解两个重要的概念。如前所述，第一个概念就是先检测达成目的的最常用的特性。对前面的例子来说，就是要先检测 document.getElementById() ，后检测 document.all 。先检测最常用的特性可以保证代码最优化，因为在多数情况下都可以避免测试多个条件。



### 9.1.1 更可靠的能力检测

能力检测对于想知道某个特性是否会按照适当方式行事（而不仅仅是某个特性存在）非常有用。

```javascript
//不要这样做！这不是能力检测——只检测了是否存在相应的方法
function isSortable(object){
    return !!object.sort;
}
```

更好的方式是检测 sort 是不是一个函数

```javascript
//这样更好：检查 sort 是不是函数
function isSortable(object){
    return typeof object.sort == "function";
}
```

**在可能的情况下，要尽量使用 typeof 进行能力检测。**



### 9.1.2 能力检测，不是浏览器检测

**检测某个或某几个特性并不能够确定浏览器。**下面给出的这段代码（或与之差不多的代码）可以在许多网站中看到，这种“浏览器检测”代码就是错误地依赖能力检测的典型示例。

```javascript
//错误！还不够具体
var isFirefox = !!(navigator.vendor && navigator.vendorSub);
//错误！假设过头了
var isIE = !!(document.all && document.uniqueID);
```

这两行代码代表了对能力检测的典型误用。以前，确实可以通过检测 navigator.vendor 和navigator.vendorSub 来确定 Firefox 浏览器。但是，Safari 也依葫芦画瓢地实现了相同的属性。于是，这段代码就会导致人们作出错误的判断。



## 9.2 怪癖检测

与能力检测类似，**怪癖检测**（quirks detection）的目标是识别浏览器的特殊行为。但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷（“怪癖”也就是 bug）。

例如，IE8 及更早版本中存在一个 bug，即如果某个实例属性与 [[Enumerable]] 标记为 false 的某个原型属性同名，那么该实例属性将不会出现在fon-in 循环当中。可以使用如下代码来检测这种“怪癖”。

```javascript
var hasDontEnumQuirk = function(){
  var o = { toString : function(){} };
  for (var prop in o){
      if (prop == "toString"){
          return false;
      }
  }
  return true;
}();
```

一般来说，“怪癖”都是个别浏览器所独有的，而且通常被归为 bug。在相关浏览器的新版本中，这些问题可能会也可能不会被修复。



## 9.3 用户代理检测

第三种，也是争议最大的一种客户端检测技术叫做**用户代理检测**。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。在每一次 HTTP 请求过程中，用户代理字符串是作为**响应首部**发送的，而且该字符串可以通过 JavaScript 的 navigator.userAgent 属性访问。

提到与用户代理字符串有关的争议，就不得不提到**电子欺骗**（spoofing）。所谓电子欺骗，就是指浏览器通过在自己的用户代理字符串加入一些错误或误导性信息，来达到**欺骗服务器**的目的。要弄清楚这个问题的来龙去脉，必须从 Web 问世初期用户代理字符串的发展讲起。



### 9.3.1 用户代理字符串的历史



### 9.3.2 用户代理字符串检测技术



### 9.3.3 完整的代码



### 9.3.4 使用方法