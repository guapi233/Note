# 模拟实现Promise/A+规范

Promise是ES2015中加入Javascript的一个相当受欢迎的特性，目的是为了解决js中令人厌恶的异步方式。Promise/A+是规定Promise的范文，这篇文章会通过Promise/A+规范，来模拟实现一个Promise，并借此来更深入的了解关于Promise的繁枝细节。



## Promise解决了什么问题？

这篇文章假定你已经有了些许的Promise使用经验。关于Promise解决的问题，大多数文章值提出了“回调地狱”这一观点，诚然，这确实是Promise解决的一大问题，但是，关于Promise的亮点，还包括但不限于以下几方面：

* 解决回调函数的控制反转导致的信任问题：

  Promise提供了针对于第三方在调用回调函数时关于错误的调用时机，错误的调用次数等方面的解决方案，具体实现可以参考[《你不知道的Javascript》中卷](https://book.douban.com/subject/26854244/) 第二部分--第三章--3.3部分--Promise信任问题 相关内容。

* 指定回调函数的方式更加灵活：

  之前的异步方式必须要在启动之前指定回调函数，这是因为以前的异步方式无法保存异步状态，导致会在得到结果后就立马进入回调函数中进行处理，而Promise因为可以保存异步的执行状态和返回值，所以无论是在异步启动前，还是启动后，甚至在已经得到结果后再指定回调函数都是被允许的。





## 宏队列与微队列

Event Loop（事件循环）是JavaScript的在执行模型，不过它并不是我们今天要探讨的，我们要引用其中两个很重的两个概念：Macrotask（宏队列）、Microtask（微队列），理解了这两个概念，可以解决我们在编写Promise中的一些疑惑。

首先先来看三段代码：

```js
// 第一段代码
setTimeout(() => {
  console.log(1); // 我后输出
}, 0)

console.log(2); // 我先输出
```

```js
// 第二段代码
Promise.resolve(1).then(resolved => console.log(resolved)); // 我后输出

console.log(2); // 我先输出
```

```js
// 第三段代码
setTimeout(() => {
  console.log(1); // 我第二个输出
  Promise.resolve(3).then((e) => console.log(e)); // 我第3个输出
}, 0);

setTimeout(() => {
  console.log(2); // 我最后输出
}, 0);
console.log(4); // 我先输出
```

从前两段代码中，我们不难看出，`setTimeout`和`Promise.prototype.then`都会异步执行其中的代码片段，但是第三段代码中，在最后加入异步队列的`Promise.prototype.then`却排在了第二个`setTimeout`前面。

我们直接说结论，原因是JavaScript的执行模型中的异步队列分为宏队列和微队列两种，其中`setTimeout`属于宏队列，`Promise.prototype.then`属于微队列。二者的共同点是都会等待JS执行栈全部pop空后才执行。

二者的区别是宏队列一次只会弹出一个回调函数执行，并且每一个宏队列函数执行完毕后，都会检测当前微队列中有无待执行函数，如果有会一次性将微队列中的全部待执行函数执行完毕。

带入到第三段代码中，Promise会先于第二个定时器就是因为第一个定时器执行完毕后，检测到微队列中包含一个Promise待执行函数，所以会将微队列的函数执行完后，再返回宏队列执行接下来的代码。

如果您依然对宏队列以及微队列抱有疑惑，无法联想出相应的执行模型，笔者推荐您可以参考一下这个[2分钟了解 JavaScript Event Loop | 面试必备](https://www.bilibili.com/video/BV1kf4y1U7Ln)视频，作者通过动画的方式，可以更加通俗易懂的了解其中的运作流程。

另外，为了通俗理解，笔者只是简单的介绍了一下两种队列的概念，上面的代码也只是运行于浏览器中的结果，node中并不遵循该执行模型，我会在另一篇文章中详细探讨一下关于Event Loop。



## 开始实现Promise

我们先看一段基本的Promise使用代码：

```js
let asyncCode = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(1);
  });
});

asyncCode.then(
  (resolved) => {
    console.log(resolved); // 1
  },
  (rejected) => {
    console.log(rejected);
  }
);
```

我们先列出从上面的代码中就可以看出的规范：

1. Promise是一个构造函数，构造一个Promise实例需要传入一个回调函数；
2. 传入的参数函数中包含两个参数，并且这两个参数也是函数；
3. 构造出的Promise实例身上包含`then`方法;
4. `then`方法中需要传入两个函数类型的参数，两个函数各有一个参数。

以上面的规则，我们就可以开始构建：

```js
(function (window) {
  function MyPromise(executor) {
    function resolve(value) {
        
    }
     
    function reject(reason) {
        
    }
    
    executor(resolve, reject)
  }

  MyPromise.prototype.then = function (onResolved, onRejected) {

  }
})(window)
```

仅仅根据上面的特征，我们发现工作无法顺利开展，于是我们需要通过阅读Promise/A+规范，来进行Promise的具体实现。



### Promise构造函数编写

根据规范，一个 Promise 的当前状态必须为以下三种状态中的一种：**等待态（Pending）**、**执行态（Fulfilled）**和**拒绝态（Rejected）**。

**等待态（Pending）**

处于等待态时，promise 需满足以下条件：

- 可以迁移至执行态或拒绝态

**执行态（Fulfilled）**

处于执行态时，promise 需满足以下条件：

- 不能迁移至其他任何状态
- 必须拥有一个**不可变**的终值

**拒绝态（Rejected）**

处于拒绝态时，promise 需满足以下条件：

- 不能迁移至其他任何状态
- 必须拥有一个**不可变**的拒因

这里的不可变指的是恒等（即可用 `===` 判断相等），而不是意味着更深层次的不可变（盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。

另外，ES2015中并没有选择”Fulfilled“作为执行态，而是选择与”rejected“相对应的“resolved”，我们的实现也遵从ES2015的实现。

```js
function MyPromise(executor) {
    // Promise当前的状态
    this.state = "pending";
    
    // 由于Promise只会有一种状态，所以我们利用一个属性来存储返回的终值或拒因
    this.data = undefined;
    
    // 使用数组是因为同一个Promise实例可能被多次调用then方法
    // 每个元素的结构：{onResolved() {}, onRejected() {}}
    this.callbacks = [];
    
    
    // ... other code
}
```

接下来我们再来实现需要传入`executor`中的`resolve`和`reject`方法，它们的逻辑包括：

1. 由于Promise只有一次更改状态的机会，所以只要当前的`state`不为`"pending"`，直接return；
2. `resolve`需要保存本次异步的终值，`reject`需要保存本次异步的拒因；
3. 由于浏览器并没有开放将代码push到微队列的接口，所以我们借用官方的`Promise.prototype.then`方法来实现合适的回调函数的调用时机。

```js
function MyPromise(executor) {
  // ... other code 
   
  function resolve(value) {
    if (this.state !== "pending") return;

    // 将状态改为resolved
    this.state = "resolved";

    // 保存value数据
    this.data = value;

    // 如果有待执行的回调函数，依次添加入异步队列中（此处用宏队列模拟微队列）
    if (this.callbacks.length > 0) {
      let _this = this;
      Promise.resolve(null).then((e) => {
        _this.callbacks.forEach((callbacksObj) => {
          callbacksObj.onResolved(value);
        });
      });
    }
  }

  function reject(reason) {
    if (this.state !== "pending") return;

    // 将状态改为rejected
    this.state = "rejected";

    // 保存reason数据
    this.data = reason;

    // 如果有待执行的回调函数，依次添加入异步队列中（此处用宏队列模拟微队列）
    if (this.callbacks.length > 0) {
      // setTimeout(() => {
      //   this.callbacks.forEach((callbacksObj) => {
      //     callbacksObj.onRejected(reason);
      //   });
      // });

      // 使用Promise.prototype.then来模拟为微队列效果
      Promise.resolve(null).then((e) => {
        this.callbacks.forEach((callbacksObj) => {
          callbacksObj.onRejected(reason);
        });
      });
    }
  }
}
```

最后因为Promise的构建是同步执行的，所以我们在构造函数中立即执行传进来的构建器：

```js
// 立即执行executor
try {
  executor(resolve.bind(this), reject.bind(this));
} catch (error) {
  reject(error); // 如果执行器抛出异常，Promise为失败状态
}
```

构造函数的最终代码为：

```js
(function (window) {
  function MyPromise(executor) {
    // Promise当前的状态
    this.state = "pending";

    // 由于Promise只会有一种状态，所以我们利用一个属性来存储返回的终值或拒因
    this.data = undefined;

    // 使用数组是因为同一个Promise实例可能被多次调用then方法
    // 每个元素的结构：{onResolved() {}, onRejected() {}}
    this.callbacks = [];

    function resolve(value) {
      if (this.state !== "pending") return;

      // 将状态改为resolved
      this.state = "resolved";

      // 保存value数据
      this.data = value;

      // 如果有待执行的回调函数，依次添加入异步队列中（此处用宏队列模拟微队列）
      if (this.callbacks.length > 0) {
        let _this = this;
        Promise.resolve(null).then((e) => {
          _this.callbacks.forEach((callbacksObj) => {
            callbacksObj.onResolved(value);
          });
        });
      }
    }

    function reject(reason) {
      if (this.state !== "pending") return;

      // 将状态改为rejected
      this.state = "rejected";

      // 保存reason数据
      this.data = reason;

      // 如果有待执行的回调函数，依次添加入异步队列中（此处用宏队列模拟微队列）
      if (this.callbacks.length > 0) {
        // setTimeout(() => {
        //   this.callbacks.forEach((callbacksObj) => {
        //     callbacksObj.onRejected(reason);
        //   });
        // });

        // 使用Promise.prototype.then来模拟为微队列效果
        Promise.resolve(null).then((e) => {
          this.callbacks.forEach((callbacksObj) => {
            callbacksObj.onRejected(reason);
          });
        });
      }
    }

    // 立即执行executor
    try {
      executor(resolve.bind(this), reject.bind(this));
    } catch (error) {
      reject(error); // 如果执行器抛出异常，Promise为失败状态
    }
  }
  
  // 用于测试，暂时假定Promise的状态为pending
  MyPromise.prototype.then = function (onResolved, onRejected) {
    this.callbacks.push({ onResolved, onRejected });
  };

  window.MyPromise = MyPromise;
})(window);

```



## 实现Promise.prototype.then

`then`方法是Promise中最重要同时也是较为复杂的一部分逻辑，理解了`then`方法的执行逻辑，后面的Promise方法就显得通俗易懂了。

那么首先我们还是先通过规范，将`then`方法的行为准则列举出来：

1. promise 的 `then` 方法接受两个参数：

   ```js
   promise.then(onFulfilled, onRejected);
   ```

2. 如果 `onFulfilled、onRejected ` 不是函数，其必须被忽略

3. 如果 `onFulfilled` 是函数：

   - 当 `promise` 执行结束后其必须被调用，其第一个参数为 `promise` 的终值
   - 在 `promise` 执行结束前其不可被调用
   - 其调用次数不可超过一次

4. 如果 `onRejected` 是函数：

   - 当 `promise` 被拒绝执行后其必须被调用，其第一个参数为 `promise` 的据因
   - 在 `promise` 被拒绝执行前其不可被调用
   - 其调用次数不可超过一次

5. `then` 方法必须返回一个 `promise` 对象

   ```js
   promise2 = promise1.then(onFulfilled, onRejected);   
   ```

   > 理解上面的“返回”部分非常重要，即：**不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected**。

前两条规则比较容易理解，我们优先实现它们：

```js
MyPromise.prototype.then = function (onResolved, onRejected) {
  // 如果传入的参数不为函数，我们为它们规定默认行为，分别为return拿到的终值和抛出拿到的拒因
  onResolved =
    typeof onResolved === "function" ? onResolved : (value) => value;
  onRejected =
    typeof onRejected === "function" ? onRejected : (reason) => { throw reason; };
};
```

第三和第四条规定了Promise状态的更新以及回调函数的执行时机，相对容易理解，所以我们接着向下查看第五条规则：规定了`then`方法的返回值为一个新的Promise。那么我们的代码就可以这样来写：

```js
MyPromise.prototype.then = function (onResolved, onRejected) {
  // ... other code
   
  // then()返回一个新的Promise用于链式调用
  return new MyPromise((resolve, reject) => {

  });
};
```

在编写里面的逻辑前，我们还需要再整理一下思绪，既然`then`方法的返回值是一个新的Promise，这不仅解释了Promise链式调用的原因，同时也带来的一个问题，这个Promise的状态如何决定？

首先，毋庸置疑的是这个Promise的返回值一定是根据`then`方法其中的`onResolved, onRejected`二者之一的执行结果来决定的。其次，根据`onResolved, onRejected`的返回值类型，要进行不同的处理，大致分为如下三种情况：

1. 如果在执行过程中出现异常，则直接变为rejected状态
2. 如果成功完成执行，且返回的值不为Promise类型，则直接变为`resolved`状态，并且将返回的值作为下一个`then`方法的值
3. 如果成功完成执行，但返回的值为新的Promise，则由这个Promise的执行结果来决定下一个`then`方法的状态

最后，由于Promise可以在任何时刻指定回调函数，所以会有当`then`方法调用时，Promise状态仍为`pending`的情况，这种情况下，我们将`onResolved, onRejected`添加到Promise的callbacks中，等待Promise中的异步执行完毕后，通过构造函数中相对应的方法来将回调函数推送到微队列中进行等待。

根据上面的所有规则，`then`方法的最终实现如下：

```js
MyPromise.prototype.then = function (onResolved, onRejected) {
  // 如果传入的参数不为函数，我们为它们规定默认行为，分别为return拿到的终值和抛出拿到的拒因
  onResolved =
    typeof onResolved === "function" ? onResolved : (value) => value;
  onRejected =
    typeof onRejected === "function" ? onRejected : (reason) => { throw reason; };

  // then()返回一个新的Promise用于链式调用
  return new MyPromise((resolve, reject) => {
    // 处理函数
    function handler(callback) {
      try {
        // 执行回调函数，获取结果，并根据不同的三种结果执行相应的逻辑
        let result = callback(SELF.data);
		
        // 如果执行结果是一个新的Promise，则以该Promise的执行结果作为结果
        if (result instanceof MyPromise) {
          result.then(resolve, reject);
        } else {
          // 如果执行结果是一个非Promise值，则直接将其作为终值返回
          resolve(result);
        }
      } catch (error) {
        // 如果在执行回调函数中捕获到异常，则将Promise更改为失败态，并将error作为拒因抛出
        reject(error);
      }
    }
	
   	// 根据三种不同的Promise状态，来决定对应的逻辑
    if (this.state === "pending") {
      // 如果执行then()时，Promise中的执行器还未产生结果，就暂时将回调函数存储起来

      this.callbacks.push({
        onResolved(value) {
          handler(onResolved);
        },
        onRejected(reason) {
          handler(onRejected);
        },
      });
    } else if (this.state === "resolved") {
      Promise.resolve(null).then((e) => {
        handler(onResolved);
      });
    } else {
      // rejected同resolved原理相同，只不过调用的是onRejected()
      Promise.resolve(null).then((e) => {
        handler(onRejected);
      });
    }
  });
};

```

注：上面代码中所使用的`Promise.resolve(null).then()`用于实现将代码推送到微队列的效果，如果使用`setTimeout`则只能将代码推送到宏队列，这与规范中的约定相违背。

