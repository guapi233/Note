# 深入浅出Event Loop

我在实现Promise那篇文章中提及到了Event Loop，并且引用了其中的两种异步队列来阐述实现Promise中的一些细节。不过Event Loop可远远没有那么简单，事实上关于它有许多我们应该注意到的细节，这些细节会让我们了解到我们的代码将在何时运行，以助于我们更加有把握的让代码按照我们理想中的顺序执行。

我搜集了许多资料，然后按照我的理解整理出了这篇文章，希望可以对你有帮助。



## 为什么Javascript要设计成单线程？

单线程规定了js一次只能做一件事，这意味着如果前面的任务非常耗时，那么后面的任务就只能在那里干瞪着眼愣着等前面的老哥跑完。如果老哥慢是因为计算量太大，导致CPU忙不过来了，那也就算了，关键是原因往往不是这样，大部分的情况都是CPU在那里闲着，因为IO设备太慢（比如HTTP请求），不得不等拿到结果后，才向下执行，而在浏览器中，如果一旦js卡顿，页面就必须停止渲染，因为渲染引擎不知道JS代码中到底有没有对DOM的操作，强行渲染只会呈现出错误的页面，这也是为什么无限循环会阻塞一切页面操作的原因。

从上面可以看出单线程存在着非常严重的弊端，那么为什么js还要被设计成单线程语言呢？有人说是因为Eich乐意，虽然我觉得这个观点很有趣，不过我还是愿意相信更为科学一点的解释。

以下证论截自阮一峰老师的博客：

> JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

一句话说就是：多线程对于高交互的浏览器来说代码编写难度太不可控了。



## 解决方案 -- Event Loop

JavaScript语言的设计者意识到，如果是因为IO设备导致的任务阻塞，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

于是，带着这种设计理念，第一版的Event Loop问世了，它将js中的任务分为同步任务和异步任务，同步任务会在代码开始执行后被直接加入调用栈，然后排队一个一个执行。而异步任务则会被推送到对应的“执行者”那里去执行（比如浏览器中的setTimeout会将其中的回调函数推送到浏览器提供的计时器API那里去计时），并在相关任务执行完毕后（比如计时结束了），将回调函数压入一个叫做“任务队列”的列表中，这个列表会在js调用栈中所有的同步代码都执行完毕后，再开始按序一个个执行。

来看一段代码：

```js
// 我在这段代码中挖了一个坑，不过我会在下面的文章中填上（笑）
setTimeout(() => {
  console.log(1);
}, 0);

setTimeout(() => {
  console.log(2);
}, 0);

console.log(3);
```

上面这段代码执行结果为`3、1、2`，您可能会疑惑：我两个计时器都设置了0毫秒延迟，按道理说不应该就是没延迟的意思吗？

结合我们上面提到的关于异步任务的执行顺序，其实结果就很明朗了：之所以0毫秒延迟依然排在同步代码的后面，是因为无论传入了多长时间的延迟，异步任务在执行结束（在这里是指计时结束）后总会被压入“任务队列”，而“任务队列”必须要等到js调用栈中的代码全部执行完才可以开始执行。

如果您觉得我的文字描述不够直观，可以结合这个[工具](https://github.com/latentflip/loupe)来搭配理解，它是Philip Roberts在JS2014CONF上演讲关于Event Loop时使用的工具，能够让您结合可视化更清楚的看到Event Loop的执行过程，同时我的文章也参考了Philip Robert的演讲。

如果您认为到这里就理解Event Loop了，那就大错特错了。事实上，关于Event Loop，还有许多可以探讨的点。



## 宏队列与微队列

您可能会发现，我在文章的最开头提到了两种异步队列，但是到目前为止只含糊的提出了一个叫“任务队列”的玩意儿。其实在前些年的浏览器中，确实只有一种“任务队列”，它其实就是现在的宏队列。而微队列是在后续的发展中更新上的，那么，为什么需要这个微队列，它与宏队列又有什么不同？

我们先来解决第一个问题，我猜您第一次听说微队列是在学习Promise的时候，我自己就是，所以我常常将Promise和微队列关联起来想。但是Promise并不是微队列推出的初衷，微队列推出的最初是为了解决DOM的变化监测问题：浏览器想要提供一种当DOM结构发生变化时所触发的事件，好让开发者能够监控到DOM的变化，于是w3c说老哥没问题，随后提供了DOM变化事件：

```js
document.body.addEventListener("DOMNodeInserted", () => {
  console.log("body里面添加了新玩意儿！")
})
```

上面的`console.log`会在body的DOM结构发生改变时触发。看起来很好，对吧？但是看看下面的代码：

```js
// 我又在这里挖了个坑，相信我，一定会在下面的文章中填上的（逃）
for (let i = 0; i < 100; i++) {
  let box = document.createElement("div");
  document.body.appendChild(box);
  box.textContent = "hi!";
}
```

上面的代码中，我创建了100个div，并将它们添加到了body元素中。你觉得这会产生多少个事件？1个？100个？不，都不是，正确答案是200个：100个div产生100个事件，并且还有100个事件是这行代码导致的。

```js
box.textContent = "hi";
```

为div设置文本的行为会产生事件，并且冒泡，导致这段简单的代码最终会产生200个事件



## 浏览器中的Event Loop







### requestAnimationFrame



### Promise与a标签







## Node中的Event Loop





### setTimeout与setImmediate

